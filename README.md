# Skipper

---

# Цель

Разработать минимально жизнеспособный компилируемый язык программирования с:

* строгой статической типизацией,
* собственным синтаксисом в стиле C,
* стековой виртуальной машиной (VM),
* JIT-компилятором (baseline — 1:1 трансляция байткода в машинный код),
* автоматическим управлением памятью с алгоритмом mark-and-sweep.

---

# Содержание (оглавление)

1. Концепция и цели MVP
2. Язык: синтаксис и семантика
3. Типы и система типов
4. Область видимости и правила перекрытия переменных (shadowing) — вариант и рекомендация для MVP
5. Управление памятью — Mark-and-Sweep (алгоритм)
6. Виртуальная машина (архитектура, набор инструкций, пример байткода)
7. JIT (собственный либо простая трансляция)
8. Инструментарий: парсер, интерпретатор, компилятор, тесты
9. Формат репозитория, документация и точки расширения
10. Примеры кода и тесты работоспособности

---

# 1. Концепция и цели MVP

MVP — язык для обучения и экспериментальной разработки: понятный синтаксис, минимальный, но достаточный набор возможностей (функции, условные переходы, циклы, рекурсия). Цель — получить исполняемый стек: от исходного кода до байткода, интерпретации на стековой VM и опционального JIT-компилятора, плюс GC mark-and-sweep для автоматического управления памятью.

Ключевые приоритеты:

* простота реализации и читаемость кода;
* детерминированность поведения (поведение ошибок, исключений и утечек должно быть предсказуемым);
* готовая основа для дальнейших оптимизаций.

---

# 2. Язык: синтаксис и семантика

## Общие правила

* Стиль: C-like. Фигурные скобки `{}` обязательны для блоков.
* Точка с запятой `;` обязательна после выражений/объявлений.
* Строгая статическая типизация: типы переменных и функций объявляются явно.
* Модульность: файлы/пространства имён.
* Комментарии: `//` строковый, `/* ... */` блочный.

## Пример функции

```sk
fn factorial(int n) -> int {
    return n <= 1 ? 1 : n * factorial(n - 1);
}
```

## Объявление переменных

```sk
int x = 5;
double pi = 3.14;
bool flag = true;
char c = 'a';
string s = "hello";
```

## Объявление функции с модификаторами доступа

```sk
fn public add(int a, int b) -> int {
    return a + b;
}
```

## Объявление `main`

```sk
class App {
    fn public main(string[] args) -> int {
        return 0;
    }
}
```

## Операторы

* Арифметические: `+`, `-`, `*`, `/`, `%`
* Сравнение: `==`, `!=`, `<`, `>`, `<=`, `>=`
* Логические: `&&`, `||`, `!`
* Присваивание: `=`
* Тернарный: `condition ? a : b`
* Унарные: `-x` (унарный минус), `!b` (логическое НЕ)

## Операторы для массивов (минимум/опционально)
* Объявление: int[] arr;
* Создание: arr = new int[10];
* Доступ: arr[5] , arr[i]
* `.length()`, `.copy()`, `.sort()`, `.print()`
* Опционально: `.append()`.

---

# 3. Типы и система типов

## Базовые типы (MVP)

* `int` — целые числа
* `double` — числа с плавающей точкой
* `bool` — логический
* `char` — символ
* `string` — строка immutable
* `array` — одномерные массивы (опционально словари/мапы)
* `struct` — набор полей
* `class` — минимальная реализация

## Типизация

* **Статическая**: все типы проверяются на этапе компиляции.
* **Сильная**: явные приведения — `int`↔`double` и т.п. требуют `cast`.

---

# 4. Область видимости и перекрытие переменных (shadowing)

Лексическая (блочная) область видимости с разрешённым shadowing

Пример:

```sk
int a = 1;
{
    int a = 2; // допустимо, внутри блока перекрывает внешнюю 'a'
}
print(a); // 1
```

---

# 5. Управление памятью — Mark-and-Sweep (MVP GC)

**Выбор:** трейсинговый сборщик — *mark-and-sweep*. Алгоритм: пометка достижимых объектов, затем освобождение непомеченных.

Ключевые шаги:

1. **Root set** — стек фреймов, глобальные переменные, регистры JIT (если имеются), статические области.
2. **Mark** — рекурсивно или итеративно пометить все достижимые объекты (grey/black sets).
3. **Sweep** — пройти по кучи и освободить все объекты, не помеченные как reachable; сбросить метки.

* GC stop-the-world.

---

# 6. Виртуальная машина (VM)

## Архитектура

* **Тип:** стековая VM (все операции работают через стек). Это упрощает дизайн байткода и интерпретатора. 
* **Две подсистемы:** интерпретатор байткода + опциональный JIT (см. ниже).
* **Стек:** хранит значения (значения могут быть tagged для поддержки загруженных типов).
* **Память:** куча для объектов (под управлением GC), стек фреймов для вызовов.

## Минимальный набор инструкций байткода (MVP)

Ниже — предложенный минимальный набор команд для стековой VM:

* `LOAD_CONST <idx>` — загрузить константу (из таблицы констант)
* `PUSH <value>` — (внутренняя команда), либо использовать `LOAD_CONST`
* `ADD` — pop a, pop b, push b + a
* `SUB` — аналогично
* `MUL`
* `DIV`
* `MOD`
* `NEG` — унарный минус
* `EQ`, `NEQ`, `LT`, `GT`, `LE`, `GE` — сравнения
* `JMP <addr>` — безусловный переход
* `JMP_IF_FALSE <addr>` — pop cond; если false -> jump
* `CALL <func_idx> <arg_count>` — вызвать функцию (push ret_addr, new frame)
* `RET` — вернуть из функции (pop frame, push return value)
* `STORE <local_idx>` — записать локальную переменную
* `LOAD <local_idx>` — загрузить локальную переменную
* `POP` — убрать из стека
* `PRINT` — вывести значение (для тестов)
* `HALT` — завершение выполнения

### Пример байткода для `print(10 + 20)`

```
LOAD_CONST 0   ; 10
LOAD_CONST 1   ; 20
ADD
PRINT
HALT
```

## Формат байткода

* Опкод (1 байт) + операнды (размер зависит от VM)

---

# 7. JIT (Just-In-Time) — baseline стратегия

## Цель MVP JIT

* **baseline JIT** — транслировать инструкцию байткода 1:1 в машинный код, кэшировать сгенерированный код и исполнять его.

---

# 8. Инструментарий (парсер, IR, компилятор, интерпретатор)

## Компоненты

1. **Лексер** — преобразует исходный код в токены.
2. **Парсер** — строит AST (рекурсивный нисходящий/анализатор LR — на выбор).
3. **Семантический анализ** — проверка типов, области видимости, связывание идентификаторов.
4. **Генератор байткода** — трансформация AST → байткод (target: VM).
5. **Интерпретатор VM** — выполняет байткод.
6. **JIT-компонент** - JIT компиляция
7. **Тестовый рантайм + сборщик мусора** — реализует runtime-API (аллокатор объектов, таблички типов, root-set API).

## Инструменты для реализации (рекомендуемые)

* Язык реализации:  **C#**, **C++**
---

# 9. Формат репозитория и документация

Будущая структура репозитория:

```
она будет тут
```

---

# 10. Примеры кода и тесты

## Пример: факториал (как source и ожидаемый байткод)

**Исходник**

```sk
fn public factorial(int n) -> int {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}
```

**Ожидаемый псевдо-байткод**

```
; function factorial
LOAD_LOCAL 0        ; n
LOAD_CONST 1
LE
JMP_IF_FALSE L1
LOAD_CONST 1
RET
L1:
LOAD_LOCAL 0
LOAD_LOCAL 0
LOAD_CONST 1
SUB
CALL factorial 1
MUL
RET
```
---


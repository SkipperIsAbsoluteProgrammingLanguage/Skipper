// ==========================================================
// SunSpider N-Body Benchmark (Standard 500K iterations)
// ==========================================================

fn sqrt(double number) -> double {
    if (number <= 0.0) { return 0.0; }
    double guess = number;
    for (int i = 0; i < 20; i = i + 1) {
        guess = 0.5 * (guess + number / guess);
    }
    return guess;
}

class Body {
    double x; double y; double z;
    double vx; double vy; double vz;
    double mass;
}

fn makeBody(double x, double y, double z, double vx, double vy, double vz, double mass) -> Body {
    Body b = new Body();
    b.x = x; b.y = y; b.z = z;
    b.vx = vx; b.vy = vy; b.vz = vz;
    b.mass = mass;
    return b;
}

fn Sun() -> Body {
    double PI = 3.141592653589793;
    double SOLAR_MASS = 4.0 * PI * PI;
    return makeBody(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, SOLAR_MASS);
}

fn Jupiter() -> Body {
    double PI = 3.141592653589793;
    double SOLAR_MASS = 4.0 * PI * PI;
    double DAYS_PER_YEAR = 365.24;
    return makeBody(
        4.84143144246472090,
        -1.16032004402742839,
        -0.10362204447112311,
        0.00166007664274403694 * DAYS_PER_YEAR,
        0.00769901118419740425 * DAYS_PER_YEAR,
        -0.00006904600169720630 * DAYS_PER_YEAR,
        0.00095479193842643660 * SOLAR_MASS
    );
}

fn Saturn() -> Body {
    double PI = 3.141592653589793;
    double SOLAR_MASS = 4.0 * PI * PI;
    double DAYS_PER_YEAR = 365.24;
    return makeBody(
        8.34336671824457987,
        4.12479856412430479,
        -0.40352341711432127,
        -0.00276742510726862411 * DAYS_PER_YEAR,
        0.00499852801234917238 * DAYS_PER_YEAR,
        0.00002304172975737639 * DAYS_PER_YEAR,
        0.00028588598066613081 * SOLAR_MASS
    );
}

fn Uranus() -> Body {
    double PI = 3.141592653589793;
    double SOLAR_MASS = 4.0 * PI * PI;
    double DAYS_PER_YEAR = 365.24;
    return makeBody(
        12.89436956213913100,
        -15.11115140169863120,
        -0.22330757889265573,
        0.00296460137564761618 * DAYS_PER_YEAR,
        0.00237847173959480950 * DAYS_PER_YEAR,
        -0.00002965895685402375 * DAYS_PER_YEAR,
        0.00004366244043351563 * SOLAR_MASS
    );
}

fn Neptune() -> Body {
    double PI = 3.141592653589793;
    double SOLAR_MASS = 4.0 * PI * PI;
    double DAYS_PER_YEAR = 365.24;
    return makeBody(
        15.37969711485091650,
        -25.91931460998796410,
        0.17925877295037118,
        0.00268067772490389322 * DAYS_PER_YEAR,
        0.00162824170038242295 * DAYS_PER_YEAR,
        -0.00009515922545197159 * DAYS_PER_YEAR,
        0.00005151389020466114 * SOLAR_MASS
    );
}

fn offsetMomentum(Body[] bodies) {
    double PI = 3.141592653589793;
    double SOLAR_MASS = 4.0 * PI * PI;
    double px = 0.0;
    double py = 0.0;
    double pz = 0.0;
    
    for (int i = 0; i < 5; i = i + 1) {
        Body b = bodies[i];
        px = px + b.vx * b.mass;
        py = py + b.vy * b.mass;
        pz = pz + b.vz * b.mass;
    }
    
    Body sun = bodies[0];
    sun.vx = (0.0 - px) / SOLAR_MASS;
    sun.vy = (0.0 - py) / SOLAR_MASS;
    sun.vz = (0.0 - pz) / SOLAR_MASS;
}

fn advance(Body[] bodies, double dt) {
    for (int i = 0; i < 5; i = i + 1) {
        Body bi = bodies[i];
        
        for (int j = i + 1; j < 5; j = j + 1) {
            Body bj = bodies[j];
            
            double dx = bi.x - bj.x;
            double dy = bi.y - bj.y;
            double dz = bi.z - bj.z;
            
            double d2 = dx * dx + dy * dy + dz * dz;
            double distance = sqrt(d2);
            double mag = dt / (d2 * distance);
            
            bi.vx = bi.vx - dx * bj.mass * mag;
            bi.vy = bi.vy - dy * bj.mass * mag;
            bi.vz = bi.vz - dz * bj.mass * mag;
            
            bj.vx = bj.vx + dx * bi.mass * mag;
            bj.vy = bj.vy + dy * bi.mass * mag;
            bj.vz = bj.vz + dz * bi.mass * mag;
        }
    }
    
    for (int i = 0; i < 5; i = i + 1) {
        Body b = bodies[i];
        b.x = b.x + dt * b.vx;
        b.y = b.y + dt * b.vy;
        b.z = b.z + dt * b.vz;
    }
}

fn energy(Body[] bodies) -> double {
    double e = 0.0;
    
    for (int i = 0; i < 5; i = i + 1) {
        Body bi = bodies[i];
        e = e + 0.5 * bi.mass * (bi.vx * bi.vx + bi.vy * bi.vy + bi.vz * bi.vz);
        
        for (int j = i + 1; j < 5; j = j + 1) {
            Body bj = bodies[j];
            double dx = bi.x - bj.x;
            double dy = bi.y - bj.y;
            double dz = bi.z - bj.z;
            double dist = sqrt(dx * dx + dy * dy + dz * dz);
            e = e - (bi.mass * bj.mass) / dist;
        }
    }
    
    return e;
}

fn main() {
    println("=== SunSpider N-Body Benchmark ===");
    
    Body[] bodies = new Body[5];
    bodies[0] = Sun();
    bodies[1] = Jupiter();
    bodies[2] = Saturn();
    bodies[3] = Uranus();
    bodies[4] = Neptune();
    
    offsetMomentum(bodies);
    
    double e1 = energy(bodies);
    println("Energy before: " + e1);
    
    //int startT = time();
    
    // Стандартные 500,000 итераций SunSpider
    for (int i = 0; i < 500000; i = i + 1) {
        advance(bodies, 0.01);
    }
    
    //int endT = time();
    
    double e2 = energy(bodies);
    println("Energy after:  " + e2);
    //println("Time (ms): " + (endT - startT));
    
    // Проверка корректности (энергия должна сохраняться)
    double diff = e1 - e2;
    if (diff < 0.0) { diff = 0.0 - diff; }
    
    if (diff < 0.01) {
        println("STATUS: PASS");
    } else {
        println("STATUS: FAIL");
    }
}